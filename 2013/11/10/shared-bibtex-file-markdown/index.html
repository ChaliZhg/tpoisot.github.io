<!DOCTYPE html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Timothée Poisot | Collaborating with markdown and bibtex</title>
    <link rel="stylesheet" href="/styles/base.css" />
    <link rel="stylesheet" href="/styles/skeleton.css" />
    <link rel="stylesheet" href="/styles/layout.css" />
    <link rel="stylesheet" href="/styles/style.css" />
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-11830706-1', 'timotheepoisot.fr');
ga('send', 'pageview');
</script>

  </head>
<body>


   <div class="container">

   <div class="three columns sidebar">
   <section id="title">
   <h1>Timothée Poisot</h1>
   <h2>Computational Ecologist</h2>
</section>

   <nav>
   <ul>
   <li><a href="/">Home</a></li>
   <li><a href="/software/">Software</a></li>
   <li><a href="/research/">Research</a></li>
   <li class="active"><a href="/blog/">Blog</a></li>
   <li><a href="/papers/">Papers</a></li>
   <li><a href="/colophon/">Colophon</a></li>
   </ul>
</nav>

   </div>

   <div class="twelve columns offset-by-three">
   <section id="content">
      <div class="post">
   <h1 class="title"> Collaborating with markdown and bibtex</h1>
   <p>The single most annoying issue when using <code>pandoc</code> to work collaboratively on papers is that it might be difficult for other people to compile the paper if they do not use your bibtex file. And if there is ony thing I avoid like the plague, it’s having several bibtex files all over the place. And I’m can’t be bothered to keep “Collections” or separate folders in Zotero. So clearly, I had to code my way out of this one.</p>
<blockquote>
<p>Sept. 24, 2014 - I have updated the code to reflect changes in the <code>bibtexparser</code> module</p>
</blockquote>
<p>The good thing of using <code>pandoc</code> is that the citation syntax is remarkably simple: <code>@key</code>. It means that using a simple <code>grep</code> command</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">grep</span> @[-:_a-zA-Z0-9]* ms.md -oh --color=never <span class="kw">|</span> <span class="kw">sort</span>  <span class="kw">|</span> <span class="kw">uniq</span> -u <span class="kw">|</span> <span class="kw">sed</span> <span class="st">&#39;s/@//g&#39;</span> <span class="kw">&gt;</span> bib.keys</code></pre>
<p>, I can generate <code>bib.keys</code>, a list with all the keys encountered in <code>ms.md</code>. The keys will be present only once, and sorted. The first few lines of one such file are</p>
<pre><code>allesina_competitive_2011
angilletta_temperature_2004
araujo_using_2011
baiser_geographic_2012
baskerville_spatial_2011
bluthgen_what_2008</code></pre>
<p>Now, I need to take each of these keys, read my big <code>library.bib</code> file, and extract only the entries that are cited in the document. So I installed a <a href="https://github.com/sciunto/python-bibtexparser">bibtex parser for python</a>, and started doing exactly that. The amazing thing is, this only takes four (interesting) lines:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co">#! /usr/bin/python2</span>

<span class="ch">import</span> sys
<span class="ch">import</span> codecs
<span class="ch">import</span> bibtexparser

<span class="kw">def</span> di2bib(di):
    b = <span class="st">&quot;@&quot;</span>+di[<span class="st">&#39;type&#39;</span>].upper()+<span class="st">&quot;{&quot;</span>+di[<span class="st">&#39;id&#39;</span>]+<span class="st">&quot;,&quot;</span>
    <span class="kw">for</span> (k, v) in di.iteritems():
        <span class="kw">if</span> k not in [<span class="st">&#39;type&#39;</span>, <span class="st">&#39;id&#39;</span>, <span class="st">&#39;abstract&#39;</span>, <span class="st">&#39;doi&#39;</span>, <span class="st">&#39;keywords&#39;</span>]:
            b += k+<span class="st">&#39; = {&#39;</span>+v+<span class="st">&#39;},</span><span class="ch">\n</span><span class="st">&#39;</span>
    b += <span class="st">&#39;}</span><span class="ch">\n</span><span class="st">&#39;</span>
    <span class="kw">return</span> b

<span class="kw">if</span> <span class="ot">__name__</span> == <span class="st">&quot;__main__&quot;</span>:
    <span class="co">## Check the number of arguments</span>
    <span class="kw">if</span> <span class="dt">len</span>(sys.argv) != <span class="dv">4</span>:
        <span class="kw">raise</span> <span class="ot">ValueError</span>(<span class="st">&quot;Wrong number of arguments&quot;</span>)
    <span class="kw">else</span> :
        key_list = sys.argv[<span class="dv">1</span>]
        bib_file = sys.argv[<span class="dv">2</span>]
        out_file = sys.argv[<span class="dv">3</span>]
    <span class="co">## The three arguments should be strings</span>
    <span class="kw">if</span> not <span class="dt">isinstance</span>(key_list, <span class="dt">str</span>):
        <span class="kw">raise</span> <span class="ot">TypeError</span>(<span class="st">&quot;The path to the list of keys should be a string&quot;</span>)
    <span class="kw">if</span> not <span class="dt">isinstance</span>(bib_file, <span class="dt">str</span>):
        <span class="kw">raise</span> <span class="ot">TypeError</span>(<span class="st">&quot;The path to the bibtex library should be a string&quot;</span>)
    <span class="kw">if</span> not <span class="dt">isinstance</span>(out_file, <span class="dt">str</span>):
        <span class="kw">raise</span> <span class="ot">TypeError</span>(<span class="st">&quot;The path to the output bibtex file should be a string&quot;</span>)
    <span class="dt">open</span>(out_file, <span class="st">&#39;w&#39;</span>).close()
    keys = [kl.rstrip(<span class="st">&quot;:</span><span class="ch">\n</span><span class="st">&quot;</span>) <span class="kw">for</span> kl in <span class="dt">open</span>(key_list, <span class="st">&#39;r&#39;</span>)]
    <span class="kw">with</span> <span class="dt">open</span>(bib_file, <span class="st">&#39;r&#39;</span>) <span class="ch">as</span> bfile:
        refs = bibtexparser.load(bfile)
    used_entries = <span class="dt">dict</span>()
    <span class="kw">with</span> codecs.<span class="dt">open</span>(out_file, encoding=<span class="st">&#39;utf-8&#39;</span>, mode=<span class="st">&#39;a&#39;</span>) <span class="ch">as</span> ofile:
        <span class="kw">for</span> e in refs.entries:
            <span class="kw">if</span> e[<span class="st">&#39;id&#39;</span>] in keys:
                ofile.write(di2bib(e))</code></pre>
<p>This code will print a list of all the keys in the <code>bib.keys</code> that have <em>not</em> been matched to an entry in the main library file. If all went well, this list should be empty.</p>
<p>And of course, you can nicely wrap things up in a <code>makefile</code>:</p>
<pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dt">python </span><span class="ch">=</span><span class="st"> python2</span>
<span class="dt">refs </span><span class="ch">=</span><span class="st"> refs.bib</span>
<span class="dt">text </span><span class="ch">=</span><span class="st"> ms.md</span>
<span class="dt">library </span><span class="ch">=</span><span class="st"> /path/to/main/bibtex/file.bib</span>

<span class="dv">$(refs):</span><span class="dt"> bib.keys</span>
   <span class="ch">$(</span><span class="dt">python</span><span class="ch">)</span> extractbib.py bib.keys <span class="ch">$(</span><span class="dt">library</span><span class="ch">)</span> <span class="ch">$(</span><span class="dt">refs</span><span class="ch">)</span>

<span class="dv">bib.keys:</span><span class="dt"> </span>
   grep @[-:_a-zA-Z0-9]* <span class="ch">$(</span><span class="dt">text</span><span class="ch">)</span> -oh --color=never | sort  | uniq -u | sed <span class="st">&#39;s/@//g&#39;</span> &gt; bib.keys</code></pre>
<p>I’m glad that I finally have a solution to this problem. Of course, a multi-author version is not difficult to do (just have each author write its own bibtex file, and put them all together before running <code>pandoc</code>). It also means that my <code>pandoc</code>-using papers are going to finally be entirely reproducible, as I’ll distribute the references list in the <em>github</em> repository.</p>
<div class="references">

</div>

</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'tpoi-hp'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


   </section>
   </div>

   </div>

</body>
</html>
