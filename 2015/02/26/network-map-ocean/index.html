<!DOCTYPE html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
extensions: ["tex2jax.js"],
jax: ["input/TeX", "output/HTML-CSS"],
tex2jax: {
inlineMath: [ ['$','$'], ["\\(","\\)"] ],
displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
processEscapes: true
},
"HTML-CSS": { availableFonts: ["TeX"] }
});
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<link href="/lib/fontawesome/css/font-awesome.min.css" rel="stylesheet">

<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-11830706-1', 'timotheepoisot.fr');
ga('send', 'pageview');
</script>

<link rel="stylesheet" href="/lib/skeleton/css/normalize.css">
<link rel="stylesheet" href="/lib/skeleton/css/skeleton.css">

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script type="text/javascript" src="/lib/site.js" charset="utf-8"></script>

<link rel="stylesheet/less" type="text/css" href="/lib/style.less" />
<script type="text/javascript" src="/lib/less.min.js" charset="utf-8"></script>

<title>Timothée Poisot | Plotting spatially explicit networks (in the oceans)</title>

  </head>
  <body><a id="pagetop"></a>

    <!-- .container is main centered wrapper -->
    <div class="container">

      <div class="head">
        <h1>Timothée Poisot</h1>
        <h2>Computational Ecologist</h2>
      </div>

      <nav class="navbar">
  <div class="container">
    <ul class="nav-list">
      <li>
        <a href="/">
          <span class="icon"><i class="fa fa-fw fa-home"></i>
          </span><span class="text">Home</span>
        </a>
      </li>
      <li>
        <a href="/software/">
          <span class="icon"><i class="fa fa-fw fa-terminal"></i>
          </span><span class="text">Software</span>
        </a>
      </li>
      <li>
        <a href="/research/">
          <span class="icon"><i class="fa fa-fw fa-flask"></i>
          </span><span class="text">Research</span>
        </a>
      </li>
      <li>
        <a href="/blog/" class="active">
          <span class="icon"><i class="fa fa-fw fa-bullhorn"></i>
          </span><span class="text">Blog</span>
        </a>
      </li>
      <li>
        <a href="/papers/">
          <span class="icon"><i class="fa fa-fw fa-file-text-o"></i>
          </span><span class="text">Papers</span>
        </a>
      </li>
      <li>
        <a href="/colophon/">
          <span class="icon"><i class="fa fa-fw fa-info"></i>
          </span><span class="text">Colophon</span>
        </a>
      </li>
    </ul>
  </div>
</nav>


      <!-- columns should be the immediate child of a .row -->
      <div class="row">
        <div class="twelve column content">
          <div class="entry">
<div class='post-title'>2015/02/26<a class="readmore" href="/2015/02/26/network-map-ocean/">Plotting spatially explicit networks (in the oceans)</a></div>
<div class='post-meta'>Written by Tim</div>
<p>One of the projects I am working on at the moment involves interactions between
marine species. We know the geographic position for each species, and their
interactions. What we wanted to come up with, is a way of showing interactions
on the map, to look at the biogeographic structure of this network. But the
thing is, because we are talking about sea-living species, it makes no sense for
the interactions to go over land. Fishes from the Pacific don&#39;t walk all the way
through South America to eat fishes from the Atlantic. Perhaps Axolotls do, and
that would be the best migration ever, but fishes don&#39;t.</p>

<p>So I started looking for a ready-made solution in <code>R</code>, and found none. Which
meant that I have to write my own! Let&#39;s start.</p>

<p>The core of the problem is that I need to draw a spline between two points, but
that spline isn&#39;t allowed to go over any land. Which is an information I can get
in <code>R</code>: with a representation of any map, I can access its polygons, then check
whether any point in <em>inside</em> the polygon. My spline isn&#39;t allowed to go through
any of these points.</p>

<p>First thing first, let&#39;s get a map of the world:</p>
<div class="highlight"><pre><code class="language-R" data-lang="R"><span class="n">library</span><span class="p">(</span><span class="n">maps</span><span class="p">)</span>
<span class="n">library</span><span class="p">(</span><span class="n">maptools</span><span class="p">)</span>
<span class="n">library</span><span class="p">(</span><span class="n">plyr</span><span class="p">)</span>
<span class="n">library</span><span class="p">(</span><span class="n">spatgraphs</span><span class="p">)</span>
<span class="n">library</span><span class="p">(</span><span class="n">spatstat</span><span class="p">)</span>

<span class="n">data</span><span class="p">(</span><span class="n">wrld_simpl</span><span class="p">)</span>
</code></pre></div>
<p>That&#39;s a lot of packages, but I will use them all in the end. The next step is
to make a regular grid, with points <em>everywhere</em>:</p>
<div class="highlight"><pre><code class="language-R" data-lang="R"><span class="c1"># Make a grid - more points = better paths
</span><span class="n">interpoint_distance</span> <span class="o">=</span> <span class="m">2</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">seq</span><span class="p">(</span><span class="n">from</span><span class="o">=</span><span class="m">-180</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="m">180</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="n">interpoint_distance</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">seq</span><span class="p">(</span><span class="n">from</span><span class="o">=</span><span class="m">-90</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="m">90</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="n">interpoint_distance</span><span class="p">)</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">expand.grid</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
</code></pre></div>
<p>Now, we can start taking each of these points, and see whether they are within a
polygon. Preliminary analyses of running time revealed that it takes
approximately forever.</p>
<div class="highlight"><pre><code class="language-R" data-lang="R"><span class="n">library</span><span class="p">(</span><span class="n">doMC</span><span class="p">)</span>
<span class="n">registerDoMC</span><span class="p">(</span><span class="m">2</span><span class="p">)</span> <span class="c1"># But I'm running it on my laptop
</span><span class="k">for</span><span class="p">(</span><span class="n">pol</span> <span class="k">in</span> <span class="n">wrld_simpl</span><span class="o">@</span><span class="n">polygons</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cat</span><span class="p">(</span><span class="s2">"Is it done yet?\n"</span><span class="p">)</span>
  <span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="k">in</span> <span class="n">pol</span><span class="o">@</span><span class="n">Polygons</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cat</span><span class="p">(</span><span class="s2">"Nope.\n"</span><span class="p">)</span>
    <span class="n">co</span> <span class="o">=</span> <span class="n">p</span><span class="o">@</span><span class="n">coords</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">aaply</span><span class="p">(</span><span class="n">as.matrix</span><span class="p">(</span><span class="n">G</span><span class="p">),</span> <span class="m">1</span><span class="p">,</span> <span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">point.in.polygon</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="m">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="m">2</span><span class="p">],</span> <span class="n">co</span><span class="p">[,</span><span class="m">1</span><span class="p">],</span> <span class="n">co</span><span class="p">[,</span><span class="m">2</span><span class="p">])</span> <span class="o">==</span> <span class="m">0</span><span class="p">,</span> <span class="n">.parallel</span><span class="o">=</span><span class="n">T</span><span class="p">),</span> <span class="p">]</span>
    <span class="n">cat</span><span class="p">(</span><span class="n">paste</span><span class="p">(</span><span class="s2">"G:"</span><span class="p">,</span> <span class="n">nrow</span><span class="p">(</span><span class="n">G</span><span class="p">),</span> <span class="s2">"\n"</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Once this is done, the <code>G</code> object actually has a list of all coordinates in our
grid that are <em>not</em> within a polygon. For example, after a few polygons, this is
what it looks like:</p>

<p><img src="/images/wmap_grid.png" alt="Map with (some) points filtered out"></p>

<p>The white areas are now empty of points. You can get to this plot with:</p>
<div class="highlight"><pre><code class="language-R" data-lang="R"><span class="n">plot</span><span class="p">(</span><span class="n">wrld_simpl</span><span class="p">)</span>
<span class="n">points</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pch</span><span class="o">=</span><span class="m">3</span><span class="p">,</span> <span class="n">cex</span><span class="o">=</span><span class="m">0.3</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="s1">'darkgrey'</span><span class="p">)</span>
</code></pre></div>
<p>And now, graph theory (don&#39;t act all surprised, you knew it was going to involve
graph theory at some point). First, we will convert the spatial coordinates into
a point pattern object. Then, we will create a spatially explicit graph, where
each point of the grid is connected to other points within a fixed distance <em>d</em>
(here being slightly larger than the diagonal of grid cells).</p>
<div class="highlight"><pre><code class="language-R" data-lang="R"><span class="n">spp</span> <span class="o">=</span> <span class="n">ppp</span><span class="p">(</span><span class="n">G</span><span class="o">$</span><span class="n">x</span><span class="p">,</span> <span class="n">G</span><span class="o">$</span><span class="n">y</span><span class="p">,</span> <span class="n">range</span><span class="p">(</span><span class="n">G</span><span class="o">$</span><span class="n">x</span><span class="p">),</span> <span class="n">range</span><span class="p">(</span><span class="n">G</span><span class="o">$</span><span class="n">y</span><span class="p">))</span>
<span class="n">spg</span> <span class="o">=</span> <span class="n">spatgraph</span><span class="p">(</span><span class="n">spp</span><span class="p">,</span> <span class="n">type</span><span class="o">=</span><span class="s2">"geometric"</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="n">interpoint_distance</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="m">2</span><span class="p">)</span><span class="m">+0.01</span><span class="p">)</span>
</code></pre></div>
<p>Problem solved! To get the path of an interaction between two points, what is
needed is the shortest path between these two points on the spatially explicit
graph. This, too, takes a while, because the algorithm used is not known for its
spectacular speed on large-ish graphs.</p>
<div class="highlight"><pre><code class="language-R" data-lang="R"><span class="c1"># Any pair of points
</span><span class="n">i</span> <span class="o">=</span> <span class="m">2000</span>
<span class="n">j</span> <span class="o">=</span> <span class="m">7600</span>
<span class="n">stp</span> <span class="o">=</span> <span class="n">shortestPath</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">spg</span><span class="p">,</span> <span class="n">spp</span><span class="p">)</span>
<span class="n">path_coord</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">stp</span><span class="o">$</span><span class="n">path</span><span class="p">,]</span>

<span class="n">plot</span><span class="p">(</span><span class="n">wrld_simpl</span><span class="p">)</span>
<span class="n">points</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pch</span><span class="o">=</span><span class="m">3</span><span class="p">,</span> <span class="n">cex</span><span class="o">=</span><span class="m">0.3</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="s1">'darkgrey'</span><span class="p">)</span>
<span class="n">lines</span><span class="p">(</span><span class="n">smooth.spline</span><span class="p">(</span><span class="n">path_coord</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="m">10</span><span class="p">),</span> <span class="n">lty</span><span class="o">=</span><span class="m">1</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="n">rgb</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0.6</span><span class="p">,</span> <span class="m">0.5</span><span class="p">),</span> <span class="n">lwd</span><span class="o">=</span><span class="m">2</span><span class="p">)</span>
</code></pre></div>
<p>And here is the result:</p>

<p><img src="/images/wmap_grid_oneint.png" alt="Map with (some) points filtered out and one interaction"></p>

<p>Now, there are a few tweaks and improvements to be made. Notably, the graph
construction should warp from the east border to the west one. But this serves
as a proof of concept. Now, let me find a few hundreds CPUs, and we&#39;ll see what
it looks like!</p>

</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'tpoi-hp'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


        </div>
      </div>

    </div>

  </body>
</html>
